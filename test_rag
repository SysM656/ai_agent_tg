#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Модернизированный Telegram-бот с интеграцией GigaChat API и RAG-функционалом
"""

import os
import logging
import tempfile
from typing import Optional, List, Dict
from pathlib import Path

from gigachat import GigaChat
from gigachat.models import Chat, Messages, MessagesRole
from telegram import Update
from telegram.ext import (
    Application,
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    ContextTypes,
    filters
)
from chromadb import Client, Settings
from chromadb.utils import embedding_functions
import PyPDF2
from docx import Document

# Настройка логирования
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Указываем GIGACHAT_CREDENTIALS прямо в коде
GIGACHAT_CREDENTIALS = "your_gigachat_credentials_here"  # Замените на реальные данные
TELEGRAM_BOT_TOKEN = "your_telegram_bot_token_here"  # Замените на реальный токен
ALLOWED_USERS = ["123456789"]  # Замените на ID пользователей, которым разрешена загрузка файлов

class DocumentProcessor:
    """Класс для обработки загруженных документов"""
    
    @staticmethod
    def extract_text_from_file(file_path: str) -> str:
        """Извлечение текста из файла в зависимости от типа"""
        ext = Path(file_path).suffix.lower()
        
        if ext == '.pdf':
            return DocumentProcessor._extract_from_pdf(file_path)
        elif ext == '.docx':
            return DocumentProcessor._extract_from_docx(file_path)
        elif ext == '.txt':
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        else:
            raise ValueError(f"Неподдерживаемый формат файла: {ext}")
    
    @staticmethod
    def _extract_from_pdf(file_path: str) -> str:
        """Извлечение текста из PDF"""
        text = ""
        with open(file_path, 'rb') as f:
            reader = PyPDF2.PdfReader(f)
            for page in reader.pages:
                text += page.extract_text() + "\n"
        return text
    
    @staticmethod
    def _extract_from_docx(file_path: str) -> str:
        """Извлечение текста из DOCX"""
        doc = Document(file_path)
        return "\n".join([para.text for para in doc.paragraphs])

class VectorDB:
    """Класс для работы с векторной базой данных"""
    
    def __init__(self):
        self.client = Client(settings=Settings(persist_directory="./chroma_db"))
        self.embedding_function = embedding_functions.SentenceTransformerEmbeddingFunction(
            model_name="sentence-transformers/paraphrase-multilingual-MiniLM-L12-v2"
        )
        self.collection = self.client.get_or_create_collection(
            name="company_documents",
            embedding_function=self.embedding_function
        )
    
    def add_document(self, document_id: str, text: str, metadata: Dict = None) -> None:
        """Добавление документа в векторную БД"""
        chunks = [text[i:i+1000] for i in range(0, len(text), 1000)]
        ids = [f"{document_id}_{i}" for i in range(len(chunks))]
        
        self.collection.add(
            documents=chunks,
            ids=ids,
            metadatas=metadata if metadata else {}
        )
    
    def query(self, query_text: str, n_results: int = 3) -> List[str]:
        """Поиск релевантных фрагментов в документах"""
        results = self.collection.query(
            query_texts=[query_text],
            n_results=n_results
        )
        return results['documents'][0]

class GigaChatClient:
    """Клиент для работы с GigaChat API с RAG-функционалом"""
    
    def __init__(self, vector_db: VectorDB):
        self.client = self._configure_client()
        self.vector_db = vector_db
    
    def _configure_client(self) -> GigaChat:
        """Конфигурация клиента GigaChat"""
        return GigaChat(
            credentials=GIGACHAT_CREDENTIALS,  # Используем переменную из кода
            verify_ssl_certs=True
        )
    
    def send_message(self, prompt: str) -> Optional[str]:
        """Отправка сообщения в GigaChat API с предварительным поиском в документах"""
        try:
            relevant_docs = self.vector_db.query(prompt)
            context = "\n\n".join(relevant_docs)
            
            system_message = Messages(
                role=MessagesRole.SYSTEM,
                content=f"Ты - помощник компании. Отвечай на вопросы, используя только предоставленную информацию:\n\n{context}"
            )
            
            user_message = Messages(
                role=MessagesRole.USER,
                content=prompt
            )
            
            chat = Chat(
                messages=[system_message, user_message],
                temperature=0.3,
                max_tokens=1000
            )
            
            response = self.client.chat(chat)
            return response.choices[0].message.content
            
        except Exception as e:
            logger.error(f"Ошибка GigaChat API: {str(e)}")
            return None

class TelegramBot:
    """Telegram бот с интеграцией GigaChat и загрузкой документов"""
    
    def __init__(self):
        self.token = TELEGRAM_BOT_TOKEN  # Используем переменную из кода
        self.vector_db = VectorDB()
        self.gigachat = GigaChatClient(self.vector_db)
        self.application = self._configure_application()
        self.allowed_users = ALLOWED_USERS  # Используем переменную из кода
    
    def _configure_application(self) -> Application:
        """Конфигурация Telegram бота с обработчиками"""
        app = ApplicationBuilder().token(self.token).build()
        
        app.add_handler(CommandHandler("start", self.start_command))
        app.add_handler(CommandHandler("help", self.help_command))
        app.add_handler(CommandHandler("upload", self.upload_command))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message))
        app.add_handler(MessageHandler(filters.Document.ALL, self.handle_document))
        
        app.add_error_handler(self.error_handler)
        
        return app
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Обработчик команды /start"""
        await update.message.reply_text(
            "Привет! Я интеллектуальный бот компании.\n\n"
            "Я могу отвечать на вопросы, используя внутренние инструкции компании.\n\n"
            "Доступные команды:\n"
            "/help - показать справку\n"
            "/upload - загрузить документ (только для админов)"
        )
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Обработчик команды /help"""
        await update.message.reply_text(
            "Доступные команды:\n"
            "/start - начать диалог\n"
            "/help - показать справку\n"
            "/upload - загрузить документ (только для админов)\n\n"
            "Просто напишите мне вопрос, и я отвечу на основе документов компании!"
        )
    
    async def upload_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Обработчик команды /upload"""
        user_id = str(update.message.from_user.id)
        
        if user_id not in self.allowed_users:
            await update.message.reply_text("У вас нет прав для загрузки документов.")
            return
        
        await update.message.reply_text(
            "Пожалуйста, отправьте документ (PDF, DOCX или TXT), который нужно добавить в базу знаний."
        )
    
    async def handle_document(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Обработчик загрузки документов"""
        user_id = str(update.message.from_user.id)
        
        if user_id not in self.allowed_users:
            await update.message.reply_text("У вас нет прав для загрузки документов.")
            return
        
        document = update.message.document
        file_name = document.file_name
        
        if not file_name.lower().endswith(('.pdf', '.docx', '.txt')):
            await update.message.reply_text(
                "Неподдерживаемый формат файла. Пожалуйста, отправьте PDF, DOCX или TXT."
            )
            return
        
        try:
            with tempfile.NamedTemporaryFile(delete=False) as temp_file:
                file = await context.bot.get_file(document.file_id)
                await file.download_to_drive(temp_file.name)
                
                text = DocumentProcessor.extract_text_from_file(temp_file.name)
                
                self.vector_db.add_document(
                    document_id=file_name,
                    text=text,
                    metadata={"uploaded_by": user_id, "filename": file_name}
                )
                
                await update.message.reply_text(
                    f"Документ {file_name} успешно добавлен в базу знаний!"
                )
                
        except Exception as e:
            logger.error(f"Ошибка обработки документа: {str(e)}")
            await update.message.reply_text(
                "Произошла ошибка при обработке документа. Пожалуйста, попробуйте позже."
            )
        finally:
            if 'temp_file' in locals() and temp_file.name:
                try:
                    os.unlink(temp_file.name)
                except:
                    pass
    
    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Обработчик текстовых сообщений с RAG"""
        user_message = update.message.text
        user_id = update.message.from_user.id
        logger.info(f"Получено сообщение от {user_id}: {user_message}")
        
        await update.message.chat.send_action(action="typing")
        
        try:
            response = self.gigachat.send_message(user_message)
            if not response:
                raise ValueError("Пустой ответ от GigaChat API")
            
            await update.message.reply_text(response)
            
        except Exception as e:
            logger.error(f"Ошибка обработки сообщения: {str(e)}")
            await update.message.reply_text(
                "Произошла ошибка при обработке вашего запроса. Пожалуйста, попробуйте позже."
            )
    
    async def error_handler(self, update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Глобальный обработчик ошибок"""
        logger.error(f"Ошибка в боте: {context.error}", exc_info=context.error)
        
        if isinstance(update, Update):
            await update.message.reply_text(
                "Произошла критическая ошибка. Разработчики уже уведомлены."
            )
    
    def run(self) -> None:
        """Запуск бота"""
        logger.info("Бот запущен")
        self.application.run_polling(drop_pending_updates=True)

if __name__ == "__main__":
    try:
        bot = TelegramBot()
        bot.run()
    except Exception as e:
        logger.critical(f"Критическая ошибка при запуске бота: {str(e)}", exc_info=True)
        raise
