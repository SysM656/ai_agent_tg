#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Полная реализация Telegram-бота с интеграцией GigaChat API
Требования:
- Python 3.8+
- Зависимости: python-dotenv, python-telegram-bot, gigachat
"""

import os
import logging
from typing import Optional

from dotenv import load_dotenv
from gigachat import GigaChat
from gigachat.models import Chat, Messages, MessagesRole
from telegram import Update
from telegram.ext import (
    Application,
    ApplicationBuilder,
    CommandHandler,
    MessageHandler,
    ContextTypes,
    filters
)

# Настройка логирования
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Загрузка переменных окружения
load_dotenv()

class GigaChatClient:
    """
    Клиент для работы с GigaChat API
    """
    
    def __init__(self):
        self.client = self._configure_client()
    
    def _configure_client(self) -> GigaChat:
        """
        Конфигурация клиента GigaChat
        """
        credentials = os.getenv("GIGACHAT_CREDENTIALS")
        if not credentials:
            raise ValueError("GIGACHAT_CREDENTIALS должен быть установлен в .env файле")
        
        return GigaChat(
            credentials=credentials,
            verify_ssl_certs=True
        )
    
    def send_message(self, prompt: str) -> Optional[str]:
        """
        Отправка сообщения в GigaChat API и получение ответа
        """
        try:
            messages = Messages(
                role=MessagesRole.USER,
                content=prompt
            )
            
            chat = Chat(
                messages=[messages],
                temperature=0.7,
                max_tokens=1000
            )
            
            response = self.client.chat(chat)
            return response.choices[0].message.content
            
        except Exception as e:
            logger.error(f"Ошибка GigaChat API: {str(e)}")
            return None

class TelegramBot:
    """
    Telegram бот с интеграцией GigaChat
    """
    
    def __init__(self):
        self.token = os.getenv("TELEGRAM_BOT_TOKEN")
        if not self.token:
            raise ValueError("TELEGRAM_BOT_TOKEN должен быть установлен в .env файле")
        
        self.gigachat = GigaChatClient()
        self.application = self._configure_application()
    
    def _configure_application(self) -> Application:
        """
        Конфигурация Telegram бота с обработчиками
        """
        app = ApplicationBuilder().token(self.token).build()
        
        # Регистрация обработчиков
        app.add_handler(CommandHandler("start", self.start_command))
        app.add_handler(CommandHandler("help", self.help_command))
        app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message))
        
        # Обработчики ошибок
        app.add_error_handler(self.error_handler)
        
        return app
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Обработчик команды /start
        """
        await update.message.reply_text(
            "Привет! Я интеллектуальный бот на базе GigaChat AI.\n\n"
            "Просто напиши мне сообщение, и я постараюсь помочь!\n\n"
            "Используй /help для просмотра доступных команд."
        )
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Обработчик команды /help
        """
        await update.message.reply_text(
            "Доступные команды:\n"
            "/start - Начать диалог\n"
            "/help - Показать это сообщение\n\n"
            "Просто напиши мне сообщение, и я отвечу!"
        )
    
    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Обработчик текстовых сообщений
        """
        user_message = update.message.text
        user_id = update.message.from_user.id
        logger.info(f"Получено сообщение от {user_id}: {user_message}")
        
        await update.message.chat.send_action(action="typing")
        
        try:
            # Отправляем запрос в GigaChat
            response = self.gigachat.send_message(user_message)
            if not response:
                raise ValueError("Пустой ответ от GigaChat API")
            
            await update.message.reply_text(response)
            
        except Exception as e:
            logger.error(f"Ошибка обработки сообщения: {str(e)}")
            await update.message.reply_text(
                "Произошла ошибка при обработке вашего запроса. Пожалуйста, попробуйте позже."
            )
    
    async def error_handler(self, update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
        """
        Глобальный обработчик ошибок
        """
        logger.error(f"Ошибка в боте: {context.error}", exc_info=context.error)
        
        if isinstance(update, Update):
            await update.message.reply_text(
                "Произошла критическая ошибка. Разработчики уже уведомлены."
            )
    
    def run(self) -> None:
        """
        Запуск бота
        """
        logger.info("Бот запущен")
        self.application.run_polling(drop_pending_updates=True)

def validate_environment() -> None:
    """
    Проверка необходимых переменных окружения
    """
    required_vars = [
        "TELEGRAM_BOT_TOKEN",
        "GIGACHAT_CREDENTIALS"
    ]
    
    missing_vars = [var for var in required_vars if not os.getenv(var)]
    if missing_vars:
        raise EnvironmentError(
            f"Отсутствуют обязательные переменные окружения: {', '.join(missing_vars)}"
        )

if __name__ == "__main__":
    try:
        validate_environment()
        bot = TelegramBot()
        bot.run()
    except Exception as e:
        logger.critical(f"Критическая ошибка при запуске бота: {str(e)}", exc_info=True)
        raise
